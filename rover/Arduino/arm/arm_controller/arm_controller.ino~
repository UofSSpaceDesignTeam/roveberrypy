#include <Wire.h>
#include <math.h>

// linear actuator control pins
#define null_pin 	0;

#define L1_A		17
#define L1_B		16
#define L1_PWM		10
#define L1_WIPER	A8

#define L2_A		15
#define L2_B		14
#define L2_PWM		9
#define L2_WIPER	A7

#define L3_A		13
#define L3_B		12
#define L3_PWM		6
#define L3_WIPER	A6

#define BASE_A		11
#define BASE_B		8
#define BASE_PWM	5

#define G1_A		7
#define G1_B		2
#define G1_PWM		4

#define G2_A		1
#define G2_B		3

// linear actuator min and max positions
#define L1_MAX			885
#define L1_MIN			591

#define L2_MAX			862
#define L2_MIN			617

#define L3_MAX			810
#define L3_MIN			260

// tolerances
#define L1_TOL			10
#define L2_TOL			10
#define L3_TOL			10

// inverse kin min and max positions
#define INVK_MAX_X 		0
#define INVK_MIN_X 		0
#define INVK_MAX_Z		0
#define INVK_MIN_Z		0
#define INVK_MAX_PHI		0
#define INVK_MIN_PHI		0

#define EXTEND  1
#define RETRACT 2
#define STILL   3

int apx_terms = 13;

struct drivePins {
    int pinA;
    int pinB;
    int pinPWM;
    int pinWiper;
    drivePins(int pinA_, int pinB_, int pinPWM_, int pinWiper_ ){
      pinA = pinA_;
      pinB = pinB_;
      pinPWM = pinPWM_;
      pinWiper = pinWiper_;
    }
    drivePins(int pinA_, int pinB_, int pinPWM_){
      pinA = pinA_;
      pinB = pinB_;
      pinPWM = pinPWM_;
      pinWiper = -1;
    }
    drivePins(int pinA_, int pinB_){
      pinA = pinA_;
      pinB = pinB_;
      pinPWM = -1;
      pinWiper = -1;
    }

    void set(int dir, int dutyCycle){
        switch(dir){
        case EXTEND:
          digitalWrite(pinA, LOW);
          digitalWrite(pinB, HIGH);
          if(pinPWM != -1)  analogWrite (pinPWM, dutyCycle);
          break;
        case RETRACT:
          digitalWrite(pinA, HIGH);
          digitalWrite(pinB, LOW );
          if(pinPWM != -1)  analogWrite (pinPWM, dutyCycle);
          break;
        case STILL:
          digitalWrite(pinA,0);
          digitalWrite(pinB,0);
          if(pinPWM != -1)  analogWrite (pinPWM,0);
          break;
        }
    }

    double readPosition(){
        if(pinWiper != -1){
            double   wiperReading[apx_terms];
            int   readingIndex[apx_terms];
            double  wiperValue = -1;
            
            for(int jdx = 0; jdx < apx_terms; jdx++){
              readingIndex[jdx] = 0;
              wiperReading[jdx] = analogRead(pinWiper);
              for(int kdx = 0; kdx < jdx; kdx++){
                if(wiperReading[kdx] == wiperReading[jdx])  wiperValue = wiperReading[jdx]; // take mode if there is one
                if(wiperReading[kdx] > wiperReading[jdx]) readingIndex[kdx]++;
                if(wiperReading[kdx] < wiperReading[jdx])   readingIndex[jdx]++;
              }
            }
            if(wiperValue != -1){ // otherwise take the median
              Serial.println("No mode found, finding median");
              for(int jdx = 0; jdx < apx_terms; jdx++){
                if(readingIndex[jdx] == int(apx_terms/2)) wiperValue = wiperReading[jdx];
              }
            } else {
              Serial.println("Mode found");
            }
            return wiperValue;
        }
        return 0;
    }

    void initalize(){
      pinMode(pinA, OUTPUT);
      pinMode(pinB, OUTPUT);
      if(pinPWM != -1)    pinMode(pinPWM,   OUTPUT);
      if(pinWiper != -1)  pinMode(pinWiper, INPUT);
    }
};

drivePins linac1(L1_A, L1_B, L1_PWM, L1_WIPER);
drivePins linac2(L2_A, L2_B, L2_PWM, L2_WIPER);
drivePins linac3(L3_A, L3_B, L3_PWM, L3_WIPER);
drivePins gripper1(G1_A, G1_B, G1_PWM);
drivePins gripper2(G1_A, G1_B);

drivePins* LA[3] = {&linac1, &linac2, &linac3 };
drivePins* G[2] = {&gripper1, &gripper2};

int dutyCycle = 255;

// actuator globals
int wiperPin[3] = {L1_WIPER, L2_WIPER, L3_WIPER};
int tolerance[3] = {L1_TOL, L2_TOL, L3_TOL};
int LA_MAX[3] = {L1_MAX, L2_MAX, L3_MAX};
int LA_MIN[3] = {L1_MIN, L2_MIN, L3_MIN};
double co0[] =	{ 790.3, 799.8};  
double co1[] =  { 83.29, 92.68};

int pphr = 13390;

// inverse kin stuff
float minOutput[3] = {0.0, 9.0, 33.0};
float maxOutput[3] = {109.0, 104.0, 100.0};
float countsPerDegree = 74.39;

double lengthLA[3];


void setPosition();

void setLAPosition();
void inverseKinematics();
void setLA(int, int);


void inverseKinematics(){
	lengthLA[0] = 80;
	lengthLA[1] = 60;
	lengthLA[2] = 70;
}
void setLAPosition(){
	
	for( int idx = 0; idx < 3; idx++ ){
		// get requested position
		double reqPos = lengthLA[idx];
		double digiLen = co1[idx]* reqPos + co0[idx];
	  	
		// get currrent position
		double physPos = LA[idx]->readPosition();

		// determine direction to go
		if 	( physPos == digiPos )	dir = STILL;
		else if	( physPos >  digiPos ) 	dir = RETRACT;
		else if ( physPos <  digiPos ) 	dir = EXTEND;

		// adjust digital position to account for tolerance
		switch(dir){
		case RETRACT:
			if( abs( digiPos - tolerance[idx]/2 - physPos ) < tolerance[idx]) 	dir = STILL;
			break;
		case EXTEND:
			if( abs( digiPos + tolerance[idx]/2 - physPos ) < tolerance[idx])	dir = STILL;
		}

		// check that linear actuator is safe to move
		// if it is safe to move then go ahead
		bool safeToMove = true;
		switch(dir){
		case EXTEND:
			safeToMove &= physPos < LA_MAX[idx];
			if(safeToMove) LA[idx]->set(EXTEND,dutyCycle);
			break;
		case RETRACT:
			safeToMove &= physPos > LA_MIN[idx];
			if(safeToMove) LA[idx]->set(RETRACT,dutyCycle);
			break;
		case STILL:
			LA[idx]->set(STILL,dutyCycle);
			break;
		}
	}
}

void setup()
{
	Serial.begin(9600);
  
  LA[0]->initalize();
  LA[1]->initalize();
  LA[2]->initalize();
  G[0] ->initalize();
  G[1] ->initalize();
  pinMode(L1_WIPER,INPUT);
}
int i = 1;
void loop(){
  Serial.println(LA[i]->readPosition());
  int input = Serial.parseInt();
  if(input == 1){
    LA[i]->set(EXTEND,255);
    delay(2000);
    LA[i]->set(STILL,0);
  } else if(input == -1){
    LA[i]->set(RETRACT,255);
    delay(2000);
    LA[i]->set(STILL,0);
  }
}

